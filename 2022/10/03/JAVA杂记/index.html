<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"invincible-nerd.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="JAVA Q&amp;A1. JAVA一个文件写多个类 ( 同级类 ) 规则和注意点 在一个.java文件中可以有多个同级类, 其修饰符只可以public／abstract／final／和无修饰符 public修饰的只能有一个,且必须要与文件名相同；  1&#x2F;&#x2F;因为jvm虚拟机为了提高查找类的速度，使用import语句导入的时候，只会导入对应空间的文件名所对应的class文件，而public文件是大">
<meta property="og:type" content="article">
<meta property="og:title" content="JAVA杂记">
<meta property="og:url" content="http://invincible-nerd.github.io/2022/10/03/JAVA%E6%9D%82%E8%AE%B0/index.html">
<meta property="og:site_name" content="IVN">
<meta property="og:description" content="JAVA Q&amp;A1. JAVA一个文件写多个类 ( 同级类 ) 规则和注意点 在一个.java文件中可以有多个同级类, 其修饰符只可以public／abstract／final／和无修饰符 public修饰的只能有一个,且必须要与文件名相同；  1&#x2F;&#x2F;因为jvm虚拟机为了提高查找类的速度，使用import语句导入的时候，只会导入对应空间的文件名所对应的class文件，而public文件是大">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-10-03T13:24:42.000Z">
<meta property="article:modified_time" content="2022-10-14T07:41:00.731Z">
<meta property="article:author" content="invincible-nerd">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://invincible-nerd.github.io/2022/10/03/JAVA%E6%9D%82%E8%AE%B0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>JAVA杂记 | IVN</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">IVN</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://invincible-nerd.github.io/2022/10/03/JAVA%E6%9D%82%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="invincible-nerd">
      <meta itemprop="description" content="For explorer everywhere">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="IVN">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          JAVA杂记
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-10-03 21:24:42" itemprop="dateCreated datePublished" datetime="2022-10-03T21:24:42+08:00">2022-10-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-10-14 15:41:00" itemprop="dateModified" datetime="2022-10-14T15:41:00+08:00">2022-10-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CS/" itemprop="url" rel="index"><span itemprop="name">CS</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>16k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>14 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="JAVA-Q-amp-A"><a href="#JAVA-Q-amp-A" class="headerlink" title="JAVA Q&amp;A"></a>JAVA Q&amp;A</h1><h2 id="1-JAVA一个文件写多个类-同级类-规则和注意点"><a href="#1-JAVA一个文件写多个类-同级类-规则和注意点" class="headerlink" title="1. JAVA一个文件写多个类 ( 同级类 ) 规则和注意点"></a>1. JAVA一个文件写多个类 ( 同级类 ) 规则和注意点</h2><ul>
<li>在一个.java文件中可以有多个同级类, 其修饰符<strong>只可以public／abstract／final／和无修饰符</strong></li>
<li><strong>public修饰的只能有一个</strong>,且必须要与文件名相同；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//因为jvm虚拟机为了提高查找类的速度，使用import语句导入的时候，只会导入对应空间的文件名所对应的class文件，而public文件是大家都要使用的，因此直接导入这个类名对应的class文件即可。</span></span><br></pre></td></tr></table></figure>



<ul>
<li><p>若<strong>没有public</strong>的则可与文件名不同</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java编译器在编译的时候，如果整个Java文件（编译单元）都没有public类（对外的公开接口类），类加载器子就无需从这方面直接去加载该编译单元产生的所有的字节码文件（.class文件），那么也就是无需去寻找编译后字节码文件存放位置。而类名和文件名一致是为了方便虚拟机在相应的路径中找到相应的类所对应的字节码文件。所以在没有public类的Java文件中，文件名和类名都没什么联系。</span></span><br></pre></td></tr></table></figure>


</li>
<li><p>该文件同级的类之间可以互相调用，但是除了public的类，其他<strong>不能够在其他文件调用</strong></p>
</li>
<li><p>在一个.java文件中由类／Enum／接口／Annotation其中<strong>至少一个</strong>类型组成。单独一个方法／变量不能独自存在与文件中，所以公用方法的封装也是做成类方法。原因是java是类加载机制，需要编译一个java文件成多个class文件，当类来使用。</p>
</li>
<li><p>用javac 编译这个.java文件的时候，它会给<strong>每一个类</strong>生成一个.class文件</p>
</li>
</ul>
<h2 id="2-抽象类可以有constructor吗？"><a href="#2-抽象类可以有constructor吗？" class="headerlink" title="2. 抽象类可以有constructor吗？"></a>2. 抽象类可以有constructor吗？</h2><p><em><strong>Yes</strong> !</em> <strong><em>*是的*</em> ！</strong> <em><strong>Abstract classes can have constructors</strong> !</em> <strong><em>*抽象类可以有构造函数*</em> ！</strong></p>
<p><em>Yes, when we define a class to be an Abstract Class it cannot be instantiated but that does not mean an Abstract class cannot have a constructor.</em> <strong>是的，当我们将类定义为抽象类时，它无法实例化，但这并不意味着抽象类不能具有构造函数。</strong> <em>Each abstract class must have a concrete subclass which will implement the abstract methods of that abstract class.</em> <strong>每个抽象类必须有一个具体的子类，它将实现该抽象类的抽象方法</strong></p>
<p><em>When we create an object of any subclass all the constructors in the corresponding inheritance tree are invoked in the top to bottom approach.</em> <strong>当我们创建任何子类的对象时，相应的继承树中的所有构造函数都是从上到下的方法调用的。</strong> <em>The same case applies to abstract classes.</em> <strong>同样的情况适用于抽象类。</strong> <em>Though we cannot create an object of an abstract class, when we create an object of a class which is concrete and subclass of the abstract class, the constructor of the abstract class is automatically invoked.</em> <strong>虽然我们不能创建抽象类的对象，但是当我们创建一个类的对象时，它是抽象类的具体和子类，抽象类的构造函数会被自动调用。</strong> <em>Hence we can have a constructor in abstract classes.</em> <strong>因此，我们可以在抽象类中使用构造函数。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">TestEngine</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">private</span> String engineId;</span><br><span class="line">   <span class="keyword">private</span> String engineName;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">TestEngine</span><span class="params">(String engineId , String engineName)</span></span><br><span class="line">   &#123;</span><br><span class="line">     <span class="built_in">this</span>.engineId = engineId;</span><br><span class="line">     <span class="built_in">this</span>.engineName = engineName;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//public gettors and settors</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">scheduleTest</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavaTestEngine</span> <span class="keyword">extends</span> <span class="title class_">TestEngine</span></span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">private</span> String typeName;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">JavaTestEngine</span><span class="params">(String engineId , String engineName , String typeName)</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="built_in">super</span>(engineId , engineName);</span><br><span class="line">      <span class="built_in">this</span>.typeName = typeName;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">scheduleTest</span><span class="params">()</span></span><br><span class="line">   &#123;</span><br><span class="line">     <span class="comment">//do Stuff</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="3-JAVA-inner-class"><a href="#3-JAVA-inner-class" class="headerlink" title="3.JAVA inner class"></a>3.JAVA inner class</h2><p>inside another class or method</p>
<ul>
<li><p>成员内部类</p>
</li>
<li><p>局部内部类</p>
</li>
<li><p>匿名内部类</p>
</li>
<li><p>静态内部类</p>
</li>
</ul>
<h2 id="4-ragged-array"><a href="#4-ragged-array" class="headerlink" title="4.ragged array"></a>4.ragged array</h2><p>java 2d array并不是真的开辟一个二维矩阵，只是指定行数，列数非必须</p>
<p>每行指向一个array object，这些array的长度可以不等</p>
<h2 id="5-JAVA-反射"><a href="#5-JAVA-反射" class="headerlink" title="5.JAVA 反射"></a>5.JAVA 反射</h2><h3 id="基础理论"><a href="#基础理论" class="headerlink" title="基础理论"></a><strong>基础理论</strong></h3><ol>
<li>A类 -&gt; A.class字节码文件 -&gt; 加载到JVM后的A字节码文件对象(Class对象)</li>
<li>A的Class对象 -&gt; A的实例</li>
<li>Class是反射的基础</li>
<li>当new一个新对象或者引用静态成员变量等时机时，JVM类加载器系统会将对应Class对象加载到JVM中，然后JVM根据Class对象创建实例对象或者提供静态变量的引用值。</li>
<li>每个类，无论创建多少个实例，在JVM中都对应同一个Class对象(类被不同的类加载器加载除外)。</li>
</ol>
<h3 id="主动引用"><a href="#主动引用" class="headerlink" title="主动引用"></a>主动引用</h3><p>对于字节码文件的加载时机，《Java虚拟机规范》中并没有进行强制约束，这点可以交给虚拟机的具体实现来自由把握。但是对于初始化阶段，《Java虚拟机规范》则是严格规定了<code>有且只有</code>六种情况必须立即对类进行“初始化”（而加载、验证、准备自然需要在此之前开始）：</p>
<ol>
<li>遇到new、getstatic、putstatic或invokestatic这四条字节码指令时，如果类型没有进行过初始化，则需要先触发其初始化阶段。<ul>
<li>使用new关键字实例化对象的时候。</li>
<li>读取或设置一个类型的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候。</li>
<li>调用一个类型的静态方法的时候。</li>
</ul>
</li>
<li>使用java.lang.reflect包的方法对类型进行反射调用的时候，如果类型没有进行过初始化，则需要先触发其初始化。</li>
<li>当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</li>
<li>当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。</li>
<li>当使用JDK 7新加入的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。</li>
<li>当一个接口中定义了JDK 8新加入的默认方法（被default关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。</li>
</ol>
<h3 id="被动引用"><a href="#被动引用" class="headerlink" title="被动引用"></a>被动引用</h3><p>这六种场景中的行为称为对一个类型进行<code>主动引用</code>。除此之外，所有引用类型的方式都不会触发初始化，称为<code>被动引用</code>。</p>
<p>被动引用<strong>不会导致初始化，但往往也是需要加载的</strong>，我们举一些例子：</p>
<ol>
<li><p>使用类加载器的loadClass()方法，不做类的初始化工作</p>
</li>
<li><p>类型.class<strong>字面量</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.myspring.service.impl;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;初始化A类&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.myspring.service.impl;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassLoadTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;===================&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;===================&quot;</span>);</span><br><span class="line">        <span class="type">Class</span> <span class="variable">c1</span> <span class="operator">=</span> A.class;</span><br><span class="line">        System.out.println(<span class="string">&quot;===================&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;===================&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>子类访问父类的静态字段(不会导致子类初始化，会导致父类初始化)</p>
</li>
<li><p>通过数组定义来引用类，不会触发此类的初始化</p>
</li>
<li><p>常量在编译阶段会存入调用类的常量池中，本质上没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化</p>
</li>
</ol>
<p>对于HotSpot虚拟机来说，可通过-XX：+TraceClassLoading参数观察到类是否会加载。而初始化时执行的是<code>&lt;clinit&gt;()方法</code>，我们可以编写静态代码块来验证此类是否初始化了。</p>
<blockquote>
<p><code>初始化阶段就是执行类构造器&lt;clinit&gt;()方法的过程</code>。<code>&lt;clinit&gt;()并不是程序员在Java代码中直接编写的方法，它是Javac编译器的自动生成物</code>。<code>&lt;clinit&gt;()方法</code>是由编译器自动收集类中的所有<code>类变量</code>的赋值动作和<code>静态语句块（static&#123;&#125;块）</code>中的语句<code>合并</code>产生的，<code>编译器收集的顺序是由语句在源文件中出现的顺序决定的</code>。</p>
</blockquote>
<h3 id="如何获取一个Class对象"><a href="#如何获取一个Class对象" class="headerlink" title="如何获取一个Class对象"></a>如何获取一个Class对象</h3><p>每个.class都是Class类的实例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTestBean</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">String</span> <span class="variable">testStr</span> <span class="operator">=</span> <span class="string">&quot;testStr&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getTestStr</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> testStr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTestStr</span><span class="params">(String testStr)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.testStr = testStr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="对象-getClass"><a href="#对象-getClass" class="headerlink" title="对象.getClass()"></a><strong>对象.getClass()</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">MyTestBean</span> <span class="variable">myTestBean1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyTestBean</span>();</span><br><span class="line">    <span class="type">Class</span> <span class="variable">c1</span> <span class="operator">=</span> myTestBean1.getClass();</span><br><span class="line">    System.out.print(<span class="string">&quot;获得的Class对象:&quot;</span>);</span><br><span class="line">    System.out.println(c1);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">获得的Class对象:<span class="keyword">class</span> <span class="title class_">com</span>.myspring.service.impl.MyTestBean</span><br></pre></td></tr></table></figure>



<h4 id="类型-class字面量"><a href="#类型-class字面量" class="headerlink" title="类型.class字面量"></a><strong>类型.class字面量</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">c1</span> <span class="operator">=</span> MyTestBean.class;</span><br><span class="line">    System.out.print(<span class="string">&quot;获得的Class对象:&quot;</span>);</span><br><span class="line">    System.out.println(c1);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="Class类的forName方法"><a href="#Class类的forName方法" class="headerlink" title="Class类的forName方法"></a><strong>Class类的forName方法</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">c1</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.myspring.service.impl.MyTestBean&quot;</span>);</span><br><span class="line">    System.out.print(<span class="string">&quot;获得的Class对象:&quot;</span>);</span><br><span class="line">    System.out.println(c1);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="类加载器的loadClass方法"><a href="#类加载器的loadClass方法" class="headerlink" title="类加载器的loadClass方法"></a><strong>类加载器的loadClass方法</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="built_in">this</span>.getClass().getClassLoader().loadClass(<span class="string">&quot;com.myspring.service.impl.MyTestBean&quot;</span>);</span><br><span class="line">    System.out.print(<span class="string">&quot;获得的Class对象:&quot;</span>);</span><br><span class="line">    System.out.println(c1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Class类源码"><a href="#Class类源码" class="headerlink" title="Class类源码"></a>Class类源码</h3><p>简而言之，我们先获取到类型A的Class对象，通过Class对象的newInstance方法可以得到A的实例。通过Class对象可以获取到Constructor对象，进一步可以使用Constructor对象来得到A的实例。通过Class对象可以获取到Method对象，通过Method的invoke方法我们可以调用一些方法。通过Class对象可以获取到Field对象，我们可以对这个实例的一些字段进行赋值取值操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 使用给定的字符串名称返回与类或接口关联的Class对象。 调用此方法等效于：Class.forName(className, true, currentLoader)currentLoader表示当前类的定义类加载器。</span></span><br><span class="line"><span class="comment">* 调用forName“X”）会导致初始化名为X的类。</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span>      className   所需类的完全限定名称。</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span>     具有指定名称的类的Class对象。</span></span><br><span class="line"><span class="comment">* ......</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; forName(String className) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line"><span class="keyword">return</span> forName0(className, <span class="literal">true</span>, ClassLoader.getClassLoader(caller), caller);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 使用给定的类加载器返回与具有给定字符串名称的类或接口关联的Class对象。</span></span><br><span class="line"><span class="comment">* 给定类或接口的完全限定名称（采用getName返回的相同格式），此方法尝试查找，加载和链接该类或接口。指定的类加载器用于加载类或接口。  </span></span><br><span class="line"><span class="comment">* 如果参数loader为null，则通过引导类加载器加载该类。仅当initialize参数为true且之前尚未初始化时，才初始化该类。</span></span><br><span class="line"><span class="comment">* 如果name表示原始类型或void，则将尝试在名称为name的未命名包中定位用户定义的类。 因此，该方法不能用于获取表示原始类型或void的任何Class对象。</span></span><br><span class="line"><span class="comment">* 如果name表示数组类，则该数组类的组件类型已加载但未初始化。</span></span><br><span class="line"><span class="comment">* 请注意，此方法会引发与加载，链接或初始化有关的错误</span></span><br><span class="line"><span class="comment">* 请注意，此方法不会检查其调用者是否可以访问所请求的类。</span></span><br><span class="line"><span class="comment">* 如果loader为null，并且存在安全管理器，并且调用方的类加载器不为null，则此方法使用RuntimePermission(“getClassLoader”)权限，以确保可以访问引导程序类加载器。</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> initialize 如果true，则将初始化该类。</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> loader     类加载器</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span>           代表所需类的类对象</span></span><br><span class="line"><span class="comment">* <span class="doctag">@exception</span> LinkageError ExceptionInInitializerError ClassNotFoundException</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; forName(String name, <span class="type">boolean</span> initialize, ClassLoader loader) <span class="keyword">throws</span> ClassNotFoundException&#123;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">return</span> forName0(name, initialize, loader, caller);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 创建此Class对象表示的类的新实例。就像通过带有空参数列表的new表达式实例化该类一样。如果尚未初始化该类，则将其初始化。</span></span><br><span class="line"><span class="comment">* 请注意，此方法传播由null构造函数引发的任何异常，包括已检查的异常。使用此方法有效地绕过了编译时异常检查，否则该检查将由编译器执行。</span></span><br><span class="line"><span class="comment">* (java.lang.reflect.Constructor)Constructor.newInstance方法通过将构造函数抛出的所有异常包装在java.lang.reflect.InvocationTargetException中从而避免了此问题。</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span>  该对象表示的类的新分配实例。</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span>  IllegalAccessException  如果该类或其无效构造函数不可访问。</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span>  InstantiationException  如果此Class表示抽象类，接口，数组类，原始类型或void；或如果类没有空构造函数；或者或实例化由于其他原因而失败。</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span>  ExceptionInInitializerError 如果此方法引发的初始化失败。</span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span>  SecurityException 如果存在安全管理器，并且调用者的类加载器与当前类的调用者的类加载器不同，并且调用SecurityManager#checkPackageAccess拒绝访问此类的程序包。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> T <span class="title function_">newInstance</span><span class="params">()</span> <span class="keyword">throws</span> InstantiationException, IllegalAccessException&#123;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">if</span> (cachedConstructor == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> == Class.class) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalAccessException</span>(<span class="string">&quot;Can not call newInstance() on the Class for java.lang.Class&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Class&lt;?&gt;[] empty = &#123;&#125;;</span><br><span class="line">        <span class="keyword">final</span> Constructor&lt;T&gt; c = getConstructor0(empty, Member.DECLARED);</span><br><span class="line">        .......</span><br><span class="line">        cachedConstructor = c;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> (InstantiationException)<span class="keyword">new</span> <span class="title class_">InstantiationException</span>(getName()).initCause(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Constructor&lt;T&gt; tmpConstructor = cachedConstructor;</span><br><span class="line"><span class="comment">// 安全性检查（与java.lang.reflect.Constructor中的相同）</span></span><br><span class="line">......</span><br><span class="line"><span class="comment">// 运行构造函数</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> tmpConstructor.newInstance((Object[])<span class="literal">null</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 返回一个包含Class对象的数组，这些对象表示此Class对象表示的类的所有public类和接口成员。这包括从超类继承的public类和接口成员，以及由该类声明的公共类和接口成员。如果此Class对象没有public成员类或接口，则此方法返回长度为0的数组。如果此Class对象表示原始类型，数组类或void，则此方法还返回长度为0的数组。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> Class&lt;?&gt;[] getClasses() &#123;......&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 返回一组Class对象的数组，这些对象反映了声明为该Class对象表示的类的成员的所有类和接口。这包括public, protected, default (package) access,private类和接口，但不包括继承的类和接口。如果类未声明任何类或接口作为成员，或者此Class对象表示原始类型，数组类或void，则此方法返回长度为0的数组。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> Class&lt;?&gt;[] getDeclaredClasses() <span class="keyword">throws</span> SecurityException &#123;......&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 返回一个包含Field对象的数组，这些对象反映了此Class对象表示的类或接口的所有可访问public字段。</span></span><br><span class="line"><span class="comment">* 如果此Class对象表示没有可访问的public字段的类或接口，则此方法返回长度为0的数组。</span></span><br><span class="line"><span class="comment">* 如果此Class对象表示一个类，则此方法返回该类及其所有超类的public字段。</span></span><br><span class="line"><span class="comment">* 如果此对象表示一个接口，则此方法返回该接口及其所有超级接口的字段。</span></span><br><span class="line"><span class="comment">* 如果此Class对象表示数组类型，原始类型或void，则此方法返回长度为0的数组。</span></span><br><span class="line"><span class="comment">* 返回数组中的元素未排序，并且没有任何特定顺序。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> Field[] getFields() <span class="keyword">throws</span> SecurityException &#123;......&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 返回Field对象的数组，该数组反映由这个class对象表示的类或接口声明的所有字段。这包括public、protected、default（package）access和private字段，但不包括继承的字段。</span></span><br><span class="line"><span class="comment">* 如果这个Class对象表示没有声明字段的类或接口，则此方法返回长度为0的数组。</span></span><br><span class="line"><span class="comment">* 如果这个Class对象表示数组类型、基元类型或void，则此方法返回长度为0的数组。</span></span><br><span class="line"><span class="comment">* 返回数组中的元素没有排序，并且没有任何特定的顺序。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> Field[] getDeclaredFields() <span class="keyword">throws</span> SecurityException &#123;......&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 返回一个Field对象，该对象反映由这个class对象表示的类或接口的指定public成员字段。name参数是一个String，指定所需字段的简单名称。</span></span><br><span class="line"><span class="comment">* 要反射的场由下面的算法确定。设C为该对象表示的类或接口：</span></span><br><span class="line"><span class="comment">* 1.如果C用指定的名称声明了一个public字段，则该字段就是要反映的字段。</span></span><br><span class="line"><span class="comment">* 2.如果在上面的步骤1中找不到任何字段，则此算法递归地应用于C的每个直接上接口。直接上接口按声明的顺序进行搜索。</span></span><br><span class="line"><span class="comment">* 3.如果在上面的步骤1和2中找不到字段，并且C有超类S，则此算法将在S上递归调用。如果C没有超类，则抛出NoSuchFieldException。</span></span><br><span class="line"><span class="comment">* 如果这个Class对象表示数组类型，则此方法找不到数组类型的length字段。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> Field <span class="title function_">getField</span><span class="params">(String name)</span> <span class="keyword">throws</span> NoSuchFieldException, SecurityException &#123;......&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 返回一个Field对象，该对象反映此Class对象表示的类或接口的指定声明字段。name参数是一个String，它指定所需字段的简单名称。</span></span><br><span class="line"><span class="comment">* 如果此Class对象表示数组类型，则此方法找不到数组类型的length字段。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> Field <span class="title function_">getDeclaredField</span><span class="params">(String name)</span><span class="keyword">throws</span> NoSuchFieldException, SecurityException &#123;......&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 返回一个数组，该数组包含Method对象，这些对象反映由该class对象表示的类或接口的所有public方法，包括由类或接口声明的方法以及从超类和超接口继承的那些方法。</span></span><br><span class="line"><span class="comment">* 如果这个Class对象表示一个类型，该类型具有多个具有相同名称和参数类型但返回类型不同的public方法，则返回的数组对这些每个方法都有一个Method对象。</span></span><br><span class="line"><span class="comment">* 如果这个Class对象表示一个具有类初始化方法&lt;clinit&gt;的类型，则返回的数组没有与之(&lt;clint&gt;)相应的method对象。</span></span><br><span class="line"><span class="comment">* 如果这个Class对象表示数组类型，那么返回的数组对于数组类型从object继承的每个public方法都有一个Method对象。它不包含clone()的Method对象。</span></span><br><span class="line"><span class="comment">* 如果这个Class对象表示接口，则返回的数组不包含object隐式声明的任何方法。因此，如果此接口或其任何一个超接口中没有显式声明方法，则返回的数组的长度为0。（请注意，表示类的Class对象始终具有从object继承的public方法。）</span></span><br><span class="line"><span class="comment">* 如果这个Class对象表示基元类型或void，则返回的数组的长度为0。</span></span><br><span class="line"><span class="comment">* 在此class对象表示的类或接口的上层接口中声明的静态方法不被视为类或接口的成员。</span></span><br><span class="line"><span class="comment">* 返回数组中的元素没有排序，并且没有任何特定的顺序。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> Method[] getMethods() <span class="keyword">throws</span> SecurityException &#123;......&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 返回一个数组，该数组包含Method对象，这些对象反映由该class对象表示的类或接口的所有已声明方法，包括public, protected, default (package) access, and private方法，但不包括继承的方法。</span></span><br><span class="line"><span class="comment">* 如果这个Class对象表示一个类型，该类型具有多个声明的方法，这些方法具有相同的名称和参数类型，但返回类型不同，则返回的数组对这些方法每个都有一个Method对象。</span></span><br><span class="line"><span class="comment">* 如果这个Class对象表示一个具有类初始化方法&lt;clinit&gt;的类型，则返回的数组没有与之(&lt;clint&gt;)相应的method对象。</span></span><br><span class="line"><span class="comment">* 如果这个Class对象表示没有声明方法的类或接口，则返回的数组的长度为0。</span></span><br><span class="line"><span class="comment">* 如果此Class对象表示数组类型，原始类型或void，则返回的数组长度为0。</span></span><br><span class="line"><span class="comment">* 返回数组中的元素没有排序，并且没有任何特定的顺序。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> Method[] getDeclaredMethods() <span class="keyword">throws</span> SecurityException &#123;......&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 返回一个Method对象，该对象反映由该class对象表示的类或接口的指定public成员方法。name参数是一个String，指定所需方法的简单名称。parameterTypes参数是一个Class对象的数组，这些对象按声明的顺序标识方法的形式参数类型。如果parameterTypes是null，则将其视为空数组。</span></span><br><span class="line"><span class="comment">* 如果name是“&lt;init&gt;&#125;”或“&lt;clinit&gt;&#125;”，则引发NoSuchMethodException。否则，要反映的方法由下面的算法确定。设C为该对象表示的类或接口：</span></span><br><span class="line"><span class="comment">* 1. C搜索匹配方法，如下所述。如果找到匹配的方法，它将被反映出来。</span></span><br><span class="line"><span class="comment">* 2. 如果在步骤1中未找到匹配方法，则：</span></span><br><span class="line"><span class="comment">* 2.1如果C是Object以外的类，那么这个算法将在C的超类上递归调用.</span></span><br><span class="line"><span class="comment">* 2.2如果C是类Object，或者C是接口，那么将搜索C的上层接口（如果有）以查找匹配的方法。如果找到任何这样的方法，它就会被反映出来。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 要在类或接口C中查找匹配的方法，请执行以下操作：如果C声明了一个具有指定名称和完全相同形式参数类型的public方法，则该方法就是所反映的方法。如果在C中发现了不止一个这样的方法，并且其中一个方法的返回类型比其他任何方法都更具体，则会反映该方法；否则任意选择其中一个方法。</span></span><br><span class="line"><span class="comment">* 请注意，一个类中可能有多个匹配的方法，因为尽管Java语言禁止一个类声明具有相同签名但返回类型不同的多个方法，而Java虚拟机是不禁止的，这增加了虚拟机的灵活性，可用于实现各种语言功能。</span></span><br><span class="line"><span class="comment">* 如果这个Class对象表示数组类型，则此方法找不到clone方法。</span></span><br><span class="line"><span class="comment">* 在此class对象表示的类或接口的上层接口中声明的静态方法不被视为类或接口的成员。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> Method <span class="title function_">getMethod</span><span class="params">(String name, Class&lt;?&gt;... parameterTypes)</span><span class="keyword">throws</span> NoSuchMethodException, SecurityException &#123;......&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 返回一个Method对象，该对象反映此Class对象表示的类或接口的指定声明方法。name参数是一个String，用于指定所需方法的简单名称，而parameterTypes参数是一个Class对象的数组，这些对象标识该方法的形式参数类型，按声明的顺序。如果在一个类中声明了一个以上具有相同参数类型的方法，并且其中一个方法的返回类型比其他方法更具体，则返回该方法。否则，可以选择其中一种方法。如果名称是“ &lt;init&gt;”或“ &lt;clinit&gt;”，则会引发&#123;<span class="doctag">@code</span> NoSuchMethodException&#125;。</span></span><br><span class="line"><span class="comment">* 如果此&#123;<span class="doctag">@code</span> Class&#125;对象表示数组类型，则此方法找不到&#123;<span class="doctag">@code</span> clone（）&#125;方法。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> Method <span class="title function_">getDeclaredMethod</span><span class="params">(String name, Class&lt;?&gt;... parameterTypes)</span><span class="keyword">throws</span> NoSuchMethodException, SecurityException &#123;......&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 返回一个数组，其中包含Constructor对象，这些对象反映由这个class对象表示的类的所有public构造函数。如果类没有public构造函数，或者类是数组类，或者类反映基元类型或void，则返回长度为0的数组。</span></span><br><span class="line"><span class="comment">* 请注意，虽然此方法返回Constructor&lt;T&gt;对象的数组（即该类中的构造函数数组），但该方法的返回类型是Constructor&lt;？&gt;[]而不是Constructor&lt;T&gt;[]。这种信息较少的返回类型是必需的，因为从该方法返回后，可以修改数组以保存不同类的Constructor对象，这将违反Constructor&lt;T&gt;[]的类型保证。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> Constructor&lt;?&gt;[] getConstructors() <span class="keyword">throws</span> SecurityException &#123;......&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 返回Constructor对象的数组，该数组反映由这个class对象表示的类声明的所有构造函数。它们是public、protected、default（package）access和private构造函数。</span></span><br><span class="line"><span class="comment">* 返回的数组中的元素没有排序，并且没有任何特定的顺序。</span></span><br><span class="line"><span class="comment">* 如果类具有默认构造函数，则它将包含在返回的数组中。</span></span><br><span class="line"><span class="comment">* 如果class对象表示接口、基元类型、数组类或void，则此方法返回长度为0的数组。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> Constructor&lt;?&gt;[] getDeclaredConstructors() <span class="keyword">throws</span> SecurityException &#123;......&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 返回一个Constructor对象，该对象反映由这个class对象表示的类的指定public构造函数。parameterTypes参数是一个Class对象的数组，这些对象按声明的顺序标识构造函数的形式参数类型。</span></span><br><span class="line"><span class="comment">* 如果这个Class对象表示在非静态上下文中声明的内部类，则形式参数类型包括显式封闭实例作为第一个参数。</span></span><br><span class="line"><span class="comment">* 要反映的构造函数是由这个class对象表示的类的public构造函数，该对象的形式参数类型与parameterTypes指定的参数类型匹配。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> Constructor&lt;T&gt; <span class="title function_">getConstructor</span><span class="params">(Class&lt;?&gt;... parameterTypes)</span><span class="keyword">throws</span> NoSuchMethodException, SecurityException &#123;......&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 返回一个Constructor对象，该对象反映此Class对象表示的类或接口的指定构造函数。parameterTypes参数是Class对象的数组，这些对象按声明的顺序标识构造函数的形式参数类型。</span></span><br><span class="line"><span class="comment">* 如果此Class对象表示在非静态上下文中声明的内部类，则形式参数类型包括显式的封闭实例作为第一个参数。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> Constructor&lt;T&gt; <span class="title function_">getDeclaredConstructor</span><span class="params">(Class&lt;?&gt;... parameterTypes)</span><span class="keyword">throws</span> NoSuchMethodException, SecurityException &#123;......&#125;</span><br></pre></td></tr></table></figure>





<h2 id="6-JAVA常量池"><a href="#6-JAVA常量池" class="headerlink" title="6.JAVA常量池"></a>6.JAVA常量池</h2><ul>
<li><p><strong>Class文件常量池</strong></p>
<p>class文件是一组以字节为单位的二进制数据流，在java代码的编译期间，我们编写的java文件就被编译为.class文件格式的二进制数据存放在磁盘中，其中就包括class文件常量池。 class文件中存在常量池（非运行时常量池），其在编译阶段就已经确定，jvm规范对class文件结构有着严格的规范，必须符合此规范的class文件才能被jvm任何和装载。为了方便说明，我们写个简单的类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">JavaBean</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">0x101</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(<span class="type">int</span> v)</span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">        <span class="built_in">this</span>.value = temp + v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getValue</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过javac命令编译之后，用javap -v 命令查看编译后的文件:</p>
<p>这个命令之后我们得到了该class文件的版本号、常量池、已经编译后的字节码（这里未列出）。既然是常量池，那么其中存放的肯定是常量，那么什么是“常量”呢？ class文件常量池主要存放两大常量：<strong>字面量和符号引用</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">JavaBasicKnowledge</span>.JavaBean</span><br><span class="line">  minor version: <span class="number">0</span></span><br><span class="line">  major version: <span class="number">52</span></span><br><span class="line">  flags: ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #<span class="number">1</span> = Methodref          #<span class="number">6.</span>#<span class="number">29</span>         <span class="comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   #<span class="number">2</span> = Fieldref           #<span class="number">5.</span>#<span class="number">30</span>         <span class="comment">// JavaBasicKnowledge/JavaBean.value:I</span></span><br><span class="line">   #<span class="number">3</span> = String             #<span class="number">31</span>            <span class="comment">// abc</span></span><br><span class="line">   #<span class="number">4</span> = Fieldref           #<span class="number">5.</span>#<span class="number">32</span>         <span class="comment">// JavaBasicKnowledge/JavaBean.s:Ljava/lang/String;</span></span><br><span class="line">   #<span class="number">5</span> = Class              #<span class="number">33</span>            <span class="comment">// JavaBasicKnowledge/JavaBean</span></span><br><span class="line">   #<span class="number">6</span> = Class              #<span class="number">34</span>            <span class="comment">// java/lang/Object</span></span><br><span class="line">   #<span class="number">7</span> = Utf8               value</span><br><span class="line">   #<span class="number">8</span> = Utf8               I</span><br><span class="line">   #<span class="number">9</span> = Utf8               s</span><br><span class="line">  #<span class="number">10</span> = Utf8               Ljava/lang/String;</span><br><span class="line">  #<span class="number">11</span> = Utf8               f</span><br><span class="line">  #<span class="number">12</span> = Utf8               ConstantValue</span><br><span class="line">  #<span class="number">13</span> = Integer            <span class="number">257</span></span><br><span class="line">  #<span class="number">14</span> = Utf8               &lt;init&gt;</span><br><span class="line">  #<span class="number">15</span> = Utf8               ()V</span><br><span class="line">  #<span class="number">16</span> = Utf8               Code</span><br><span class="line">  #<span class="number">17</span> = Utf8               LineNumberTable</span><br><span class="line">  #<span class="number">18</span> = Utf8               LocalVariableTable</span><br><span class="line">  #<span class="number">19</span> = Utf8               <span class="built_in">this</span></span><br><span class="line">  #<span class="number">20</span> = Utf8               LJavaBasicKnowledge/JavaBean;</span><br><span class="line">  #<span class="number">21</span> = Utf8               setValue</span><br><span class="line">  #<span class="number">22</span> = Utf8               (I)V</span><br><span class="line">  #<span class="number">23</span> = Utf8               v</span><br><span class="line">  #<span class="number">24</span> = Utf8               temp</span><br><span class="line">  #<span class="number">25</span> = Utf8               getValue</span><br><span class="line">  #<span class="number">26</span> = Utf8               ()I</span><br><span class="line">  #<span class="number">27</span> = Utf8               SourceFile</span><br><span class="line">  #<span class="number">28</span> = Utf8               StringConstantPool.java</span><br><span class="line">  #<span class="number">29</span> = NameAndType        #<span class="number">14</span>:#<span class="number">15</span>        <span class="comment">// &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">  #<span class="number">30</span> = NameAndType        #<span class="number">7</span>:#<span class="number">8</span>          <span class="comment">// value:I</span></span><br><span class="line">  #<span class="number">31</span> = Utf8               abc</span><br><span class="line">  #<span class="number">32</span> = NameAndType        #<span class="number">9</span>:#<span class="number">10</span>         <span class="comment">// s:Ljava/lang/String;</span></span><br><span class="line">  #<span class="number">33</span> = Utf8               JavaBasicKnowledge/JavaBean</span><br><span class="line">  #<span class="number">34</span> = Utf8               java/lang/Object</span><br></pre></td></tr></table></figure>


</li>
<li><p><strong>运行时常量池</strong></p>
</li>
<li><p><strong>全局字符串常量池</strong></p>
</li>
<li><p><strong>基本类型包装类对象常量池</strong></p>
</li>
</ul>
<h2 id="7-JAVA-map-keySet-map-Values"><a href="#7-JAVA-map-keySet-map-Values" class="headerlink" title="7.JAVA map.keySet() map.Values()"></a>7.JAVA map.keySet() map.Values()</h2><p>一言以蔽之，shallow copy而非deep copy</p>
<p>map变了，这些set, collection也跟着变</p>
<p>尝试变这些set? 不行！</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Map</span>&lt;<span class="title class_">Integer</span>,<span class="title class_">Integer</span>&gt; map=<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="title class_">Set</span>&lt;<span class="title class_">Integer</span>&gt; keys = map.<span class="title function_">keySet</span>();</span><br><span class="line">map.<span class="title function_">put</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(map.<span class="title function_">keySet</span>());<span class="comment">//[1]</span></span><br><span class="line"><span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(keys);<span class="comment">//[1]</span></span><br><span class="line"><span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(map.<span class="title function_">keySet</span>()==keys);<span class="comment">//true</span></span><br><span class="line"><span class="title class_">Collection</span>&lt;<span class="title class_">Integer</span>&gt; values = map.<span class="title function_">values</span>();</span><br><span class="line">map.<span class="title function_">put</span>(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(values);<span class="comment">//[1, 3]</span></span><br><span class="line">keys.<span class="title function_">add</span>(<span class="number">5</span>);<span class="comment">//UnsupportedOperationException extends RuntimeException</span></span><br><span class="line"><span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(map.<span class="title function_">keySet</span>());</span><br></pre></td></tr></table></figure>


    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>invincible-nerd
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://invincible-nerd.github.io/2022/10/03/JAVA%E6%9D%82%E8%AE%B0/" title="JAVA杂记">http://invincible-nerd.github.io/2022/10/03/JAVA杂记/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/07/29/%E6%96%B0%E6%96%87%E7%AB%A0/" rel="prev" title="新文章">
      <i class="fa fa-chevron-left"></i> 新文章
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/10/07/meeting-room/" rel="next" title="meeting room">
      meeting room <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#JAVA-Q-amp-A"><span class="nav-number">1.</span> <span class="nav-text">JAVA Q&amp;A</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-JAVA%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%E5%86%99%E5%A4%9A%E4%B8%AA%E7%B1%BB-%E5%90%8C%E7%BA%A7%E7%B1%BB-%E8%A7%84%E5%88%99%E5%92%8C%E6%B3%A8%E6%84%8F%E7%82%B9"><span class="nav-number">1.1.</span> <span class="nav-text">1. JAVA一个文件写多个类 ( 同级类 ) 规则和注意点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%8F%AF%E4%BB%A5%E6%9C%89constructor%E5%90%97%EF%BC%9F"><span class="nav-number">1.2.</span> <span class="nav-text">2. 抽象类可以有constructor吗？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-JAVA-inner-class"><span class="nav-number">1.3.</span> <span class="nav-text">3.JAVA inner class</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-ragged-array"><span class="nav-number">1.4.</span> <span class="nav-text">4.ragged array</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-JAVA-%E5%8F%8D%E5%B0%84"><span class="nav-number">1.5.</span> <span class="nav-text">5.JAVA 反射</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA"><span class="nav-number">1.5.1.</span> <span class="nav-text">基础理论</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E5%8A%A8%E5%BC%95%E7%94%A8"><span class="nav-number">1.5.2.</span> <span class="nav-text">主动引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A2%AB%E5%8A%A8%E5%BC%95%E7%94%A8"><span class="nav-number">1.5.3.</span> <span class="nav-text">被动引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E4%B8%80%E4%B8%AAClass%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.5.4.</span> <span class="nav-text">如何获取一个Class对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1-getClass"><span class="nav-number">1.5.4.1.</span> <span class="nav-text">对象.getClass()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B-class%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="nav-number">1.5.4.2.</span> <span class="nav-text">类型.class字面量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Class%E7%B1%BB%E7%9A%84forName%E6%96%B9%E6%B3%95"><span class="nav-number">1.5.4.3.</span> <span class="nav-text">Class类的forName方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84loadClass%E6%96%B9%E6%B3%95"><span class="nav-number">1.5.4.4.</span> <span class="nav-text">类加载器的loadClass方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Class%E7%B1%BB%E6%BA%90%E7%A0%81"><span class="nav-number">1.5.5.</span> <span class="nav-text">Class类源码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-JAVA%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="nav-number">1.6.</span> <span class="nav-text">6.JAVA常量池</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-JAVA-map-keySet-map-Values"><span class="nav-number">1.7.</span> <span class="nav-text">7.JAVA map.keySet() map.Values()</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">invincible-nerd</p>
  <div class="site-description" itemprop="description">For explorer everywhere</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">81</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">34</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2022-04 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">invincible-nerd</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">1m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">15:48</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
